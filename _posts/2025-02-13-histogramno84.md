---
layout: single
comments: true
title: "84번 문제 히스토그램의 가장 큰 사각형 "
categories: TIL
---





### 📆 오늘의 TIL (Today I Learned)

---



# [84. 히스토그램의 가장 큰 사각형]

(https://leetcode.com/problems/largest-rectangle-in-histogram/)

`heights`히스토그램의 막대 높이를 나타내는 정수 배열이 주어지고 각 막대의 너비가 인 경우 *히스토그램에서 가장 큰 사각형의 면적을*`1` 반환합니다 .

 

**예시 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
입력: 높이 = [2,1,5,6,2,3]
 출력: 10
 설명: 위는 각 막대의 너비가 1인 히스토그램입니다.
가장 큰 직사각형은 빨간색 영역에 표시되어 있으며, 면적은 10단위입니다.
```

**예시 2:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
입력: 높이 = [2,4]
 출력: 4
```

 

**제약사항:**

- `1 <= heights.length <= 105`
- `0 <= heights[i] <= 104`

### 문제 해결

---

해당 문제는 주어진 히스토그램에서  표시된 직사각형의 넓이를 구하는 문제이다.

각 칸당 넓이가 1이고, 높이에 따라 최대 10까지 가능하다.



문제만 보았을 경우 이게 뭐지 싶었다.

풀이를 보고나서야 어떤 문제인지 이해 할 수 있었다.



해당 문제를 풀기 위해 스택을 사용하는 방법이 있는데 이를 알아보기로 했다.

### 핵심 개념

---



- **스택을 사용한 높이 관리**: 현재 높이보다 큰 요소가 있으면 스택에서 pop하여 직사각형 넓이를 계산.
- **각 히스토그램 막대의 최대 가능한 넓이 계산**: `height * width`를 활용.
- **남은 스택 요소 처리**: 모든 요소를 순회한 후에도 스택에 남아있는 요소를 고려하여 넓이 갱신.



### 정답

___



    public class Solution {
        public int LargestRectangleArea(int[] heights) {
            // 스택을 사용하여 히스토그램의 최대 직사각형 넓이를 구하는 알고리즘
            Stack<(int index, int height)> stack = new Stack<(int, int)>();
            int result = 0;
    
            for (int i = 0; i < heights.Length; i++) {
                int width = i; // 현재 인덱스를 넓이의 초기값으로 설정
                
                // 스택의 top이 현재 높이보다 크다면 pop하여 넓이를 계산
                while (stack.Count > 0 && stack.Peek().height > heights[i]) {
                    var (idx, h) = stack.Pop();
                    width = idx; // pop한 값의 인덱스를 width로 갱신
                    result = Math.Max(result, h * (i - idx)); // 최댓값 갱신
                }
                
                // 현재 높이와 넓이를 스택에 추가
                stack.Push((width, heights[i]));
            }
    
            // 스택에 남아있는 요소 처리
            foreach (var (idx, h) in stack) {
                result = Math.Max(result, h * (heights.Length - idx));
            }
            
            return result; // 최대 직사각형 넓이 반환
        }
    }
각 막대에 대해 **그 막대가 확장될 수 있는 최대 영역을 찾는 것**이 핵심.

1.**스택을 활용하여 현재까지의 히스토그램 정보를 저장**

- `(index, height)` 형태로 저장하여 나중에 넓이 계산 시 인덱스 정보를 활용.

2.**현재 높이보다 낮은 값이 나오면 pop**

- pop한 높이를 기준으로 넓이를 계산하고, 최댓값 갱신.

  - 스택이[1,5,6]인 경우 기존의 히스토 그램에 새로운 2가 들어와도 최대높이 인 6이 변하지 않음

  - 7이 들어오는 경우 6보다 크기 때문에 더 큰 값을 저장 할 수 있음

  - **[1, 1, 1, 1, 1, 1, 1, 1, 3, 4, 1, 1, 1, 1, 1, 1, 1 ,1, 1, 1]**와 같이 높이는 1로 이루어진 넓이 7의 사각형이 만들어 질 수도 있음

  - 그래서 인덱스값이 필요하다.

  - 스택 상태: `[[1, 1], [2, 5], [3, 6]]`

    - 여기서 `(1,1)`, `(2,5)`, `(3,6)`는 `(인덱스, 높이)` 쌍을 의미한다.

    이제 **높이 2를 가진 히스토그램**이 들어온다고 가정할때

    새로 들어올 값: `[4, 2]`

    이전 값(5,6)의 넓이에 영향을 미치는가?

    - 높이 2가 들어오면, **스택의 top `(3,6)`보다 작다** → pop!

    `(3,6)` pop 및 넓이 계산

    - pop된 값: `(3,6)`
    - 넓이 계산: `6 * (4 - 3) = 6`

    `(2,5)` pop 및 넓이 계산

    - pop된 값: `(2,5)`
    - 넓이 계산: `5 * (4 - 2) = 10

3.**끝까지 순회한 후, 남아있는 값들 처리**

- 모든 히스토그램을 다 돌고도 스택에 남아있는 값들은 배열 끝까지 확장될 수 있음.

- 남은 스택 확인

  - 현재 스택에는 `(1,1)`만 남음 → 더 이상 pop 안 함.
  - 새로 들어온 `(4,2)`를 스택에 추가.

  ## 올바른 스택 변화 과정

  | Step                    | 스택 상태 (인덱스, 높이) | 설명                          |
  | ----------------------- | ------------------------ | ----------------------------- |
  | 초기 상태               | `(1,1), (2,5), (3,6)`    | 기존 스택                     |
  | `2`(인덱스 `4`) 추가 시 | `(1,1), (2,5)`           | `(3,6)` pop 후 넓이 `6` 계산  |
  |                         | `(1,1)`                  | `(2,5)` pop 후 넓이 `10` 계산 |
  | `2` 추가 완료           | `(1,1), (4,2)`           | `(4,2)` push                  |

  ---

다시 문제로 돌아가자

입력:

### `heights = [2,1,5,6,2,3]`

| Step            | 스택 상태 `(index, height)`            | 설명                                                |
| --------------- | -------------------------------------- | --------------------------------------------------- |
| `2` 추가        | `[(0,2)]`                              | 초기 스택                                           |
| `1` 추가        | `[(0,2)] → pop, [(0,1)]`               | `2`가 pop됨 (넓이 = 2×1 = 2)                        |
| `5` 추가        | `[(0,1), (1,5)]`                       | 5 추가                                              |
| `6` 추가        | `[(0,1), (1,5), (2,6)]`                | 6 추가                                              |
| `2` 추가        | `[(0,1), (1,5)] → pop, [(0,1), (1,2)]` | `6` pop (넓이 = 6×1 = 6), `5` pop (넓이 = 5×2 = 10) |
| `3` 추가        | `[(0,1), (1,2), (4,3)]`                | 3 추가                                              |
| **마지막 정리** | `[(0,1)] → pop, [(0,1)] → pop`         | 2×4 = 8, 1×6 = 6                                    |

---

스택의 개념이 아직 익숙치 않아서 문제가 이해가 되지 않았는데 코드를 보니

풀이과정이 생각보다 간단해서 놀랐고 스택을 활용하는 새로운 예제를 하나 알게 되었다.

팝은 스택위의 가장 위를 제거 

푸시는 스택에서 가장 위에 추가

해당 문제의 원리는 **현재 값이 top보다 작으면, top에 저장된 직사각형의 확장이 불가능해지고 계산!**

넓이 = (현재 인덱스 - pop된 인덱스) * pop된 높이

> 0번 인덱스에 2> 새로운 1이 추가되었으나 top보다 작음으로 넓이 계산 2x1 =2 | 현재 스택{[0,1]}
>
> 

> 2번 인덱스에 5추가 > 현재 탑이 1 이므로 추가된값이 1보다 크기에 추가 | 현재스택 {[0,1],[2,5]}
>
> 3번 인덱스에 6추가 > 5보다 큼으로 6추가 | 현재스택 {[0,1],[2,5],[3,6]}
>
> 4번 인덱스에 2추가> 6보다 작음으로 6을 pop 하고 계산 6x(4-3) = 6 | 현재 스택{[0,1],[2,5]}
>
> 이제 top은 `(2,5)`이고, 여전히 현재 들어오려는 값 `2`보다 큼 > 5를 pop 하고 계산 5X(4-2) =1 0 
>
> |현재 스택{[0,1]}
>
> 4번 인덱스에 2가 추가되었음으로 마지막으로 pop된 [2,5]의 인덱스 계승 | 현재 스택{[0,1],[2,2]}



>5번 인덱스에 3추가 > 현재 top은 2 보다 새로추가된 3이 크기 때문에 push
>
>## **왜 `(4,3)`이 아니라 `(5,3)`이 아닐까?**
>
>- `(4,3)`은 **현재 값(3)의 인덱스 `5`를 그대로 넣는 것이 아님!**
>- **현재 스택의 top(2)의 확장을 위해 pop을 하지 않았기 때문!**
>- 즉, `3`은 **이전 값 `2`의 바로 뒤에서 시작해야 하므로, `index=4`에 들어간다.**
>-  현재 스택{[0,1],[2,2],[4,3]}
>
>**pop할 때 마지막으로 pop된 값의 인덱스를 계승해서 push한다.**
>
>**새로운 값이 기존 top보다 크다면 그대로 push하면 된다.**
>
>**이 과정을 반복하며 스택을 유지한다.**

---

스택에 대해 모르니 문제를 이해하기가 굉장히 어려웠다. 이번 문제를 통해 스택을 공부 할 수 있었다.

