---
layout: single
comments: true
title: "733번 홍수매립지 "
categories: TIL
---





### 📆 오늘의 TIL (Today I Learned)

---

# [733. 홍수매립지]



```
m x n`정수 그리드 로 표현된 이미지가 주어지며 `image`, 여기서 는 `image[i][j]`이미지의 픽셀 값을 나타냅니다. 또한 세 개의 정수 `sr`, `sc`, , 가 주어집니다. 귀하의 작업은 픽셀에서 시작하여 이미지에 **플러드 필을**`color` 수행하는 것입니다 .`image[sr][sc]
```

**홍수 채우기를** 수행하려면 :

1. 시작 픽셀에서 시작하여 색상을 .으로 변경합니다 `color`.
2. 원래 픽셀과 수평 또는 수직으로 면을 공유하는 픽셀( **바로 인접한** 픽셀)과 시작 픽셀과 **동일한 색상을** 공유하는 각 픽셀에 대해 동일한 프로세스를 수행합니다 .
3. *업데이트된* 픽셀의 이웃 픽셀을 확인하고 원래 시작 픽셀의 색상과 일치하는 경우 해당 색상을 수정하여 이 과정을 계속 **반복합니다 .**
4. 원래 색상의 인접 픽셀을 **더 이상 업데이트할 수 없으면** 프로세스 가 **중지됩니다 .**

채우기 작업을 수행한 후 **수정된** 이미지를 반환합니다 .

 

**예시 1:**

**입력:** 이미지 = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, 색상 = 2

**출력:** [[2,2,2],[2,2,0],[2,0,1]]

**설명:**

![img](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)

위치가 있는 이미지의 중심 `(sr, sc) = (1, 1)`(즉, 빨간색 픽셀)부터 시작해서 시작 픽셀(즉, 파란색 픽셀)과 같은 색상의 경로로 연결된 모든 픽셀은 새로운 색상으로 채색됩니다.

아래쪽 모서리는 시작 픽셀과 수평 또는 수직으로 연결되지 않았으므로 2로 채색 **되지 않았습니다** .

**예시 2:**

**입력:** 이미지 = [[0,0,0],[0,0,0]], sr = 0, sc = 0, 색상 = 0

**출력:** [[0,0,0],[0,0,0]]

**설명:**

시작 픽셀은 이미 0으로 채색되어 있으며, 이는 대상 색상과 동일합니다. 따라서 이미지에는 변경 사항이 없습니다.

 

**제약사항:**

- `m == image.length`
- `n == image[i].length`
- `1 <= m, n <= 50`
- `0 <= image[i][j], color < 216`
- `0 <= sr < m`
- `0 <= sc < n`

---

알고리즘 문제는 너무 어려운 것 같다...

문제 자체를 이해하지 못하니 풀이를 보고 코드분석하고 그러다 보면 어느새 저녁이고...

---

#### 1. 문제분석

예시로 보았을때 2차원 배열을 사용하는것 같다. 배열안의 배열의 구조가 있고 색이 칠해져있는 부분만 숫자가 바뀐다.

---

##### 풀이

```
주어진 image 그래프에서 (sr, sc) 위치에서부터 시작해 상,하,좌,우 4방향을 탐색하면서 image[sr][sc]와 값이 같다면, 해당 자리를 color 값으로 치환
```



##### 코드

```
public class Solution {
    public int[][] FloodFill(int[][] image, int sr, int sc, int color) {
        int N = image.Length;
        int M = image[0].Length;
        bool[,] visited = new bool[N, M];  // 방문 여부를 저장하는 배열
        int targetColor = image[sr][sc];   // 시작 픽셀의 색상

        void Dfs(int r, int c) {
            visited[r, c] = true;
            image[r][c] = color;

            int[][] directions = new int[][] {
                new int[] { 0, 1 },  // 오른쪽
                new int[] { 1, 0 },  // 아래
                new int[] { 0, -1 }, // 왼쪽
                new int[] { -1, 0 }  // 위쪽
            };

            foreach (var dir in directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // 범위 체크 + 방문 여부 + 같은 색인지 확인
                if (nr >= 0 && nr < N && nc >= 0 && nc < M) {
                    if (!visited[nr, nc] && image[nr][nc] == targetColor) {
                        Dfs(nr, nc);
                    }
                }
            }
        }

        // 색이 이미 원하는 색과 동일한 경우 변경할 필요 없음
        if (image[sr][sc] != color) {
            Dfs(sr, sc);
        }

        return image;
    }
}

```

시작 좌표와 같은 색상의 영역을 모두 컬러로 변경

DFS를 사용하면 쉽게 해결 할 수 있다고 한다.

##### DFS

- 깊이 우선 탐색은 맹목적 탐색방법의 하나로 탐색트리의 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 동작자 중 하나를 적용하여 트리에 다음 수준의 한 개의 자식노드를 첨가하며, 첨가된 자식 노드가 목표노드일 때까지 앞의 자식 노드의 첨가 과정을 반복해 가는 방식이다

Dfs의 코드는 방문여부를 확인하고 해당 좌표를 새로운 color로 지정한다.

0,0 을 기준으로 direction 배열에서 방향을 찾고 이동한다.

foreach문 안의 if문을 사용하여 방문한 곳인지, 같은색인지, 범위가 어떻게 되는지 확인하고 Dfs를 호출한다.

만약 좌표의 색이 이미 color와 같다면 dfs를 실행하지 않는다.

---

막상 분석해 보니 생각보다 간단한 문제였다. 84번 문제가 너무 어려워서 쉬어보이는건가..

알고리즘은 주어진 문제를 어떻게 이해하고 이에 대해 최적화된 답변을 내놓을 수 있는지가 중요한 키포인트 라는 생각이 들었고 분석과 이해를 통해 해당 구조를 학습 할 수 있었다.





