---
layout: single
comments: true
title: "300번 가장 긴 시퀀스 증가 부분 "
categories: TIL
---





### 📆 오늘의 TIL (Today I Learned)

---

# [300. 가장 긴 시퀀스 증가 부분]

정수 배열이 주어지면 ***엄격하게 증가하는*** *가장 긴 배열의 길이를*`nums` 반환합니다.

***하위 시퀀스***.

**예시 1:**

```
입력: nums = [10,9,2,5,3,7,101,18]
 출력: 4
 설명: 가장 긴 증가 부분 수열은 [2,3,7,101]이므로 길이는 4입니다.
```

**예시 2:**

```
입력: nums = [0,1,0,3,2,3]
 출력: 4
```

**예시 3:**

```
입력: nums = [7,7,7,7,7,7,7]
 출력: 1
```

 

**제약사항:**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

---

정수의 배열이 주어지고 엄격?하게 증가하느 가장 긴 배열의 길이를 nums에 반환한다.

```
public class Solution {
    public int LengthOfLIS(int[] nums) {
        if (nums.Length == 0) return 0;//nums의 길이가 0이면 0반환

        int[] dp = new int[nums.Length];
        Array.Fill(dp, 1);  // 모든 요소를 1로 초기화

        int maxLIS = 1;  // 최대 LIS 길이 저장

        for (int i = 1; i < nums.Length; i++) {// nums의 길이만큼 반복
            for (int j = 0; j < i; j++) {// j가 i보다 작으면 반복
                if (nums[i] > nums[j]) {//i가 j보다 크면
                    dp[i] = Math.Max(dp[i], dp[j] + 1);
                }
            }
            maxLIS = Math.Max(maxLIS, dp[i]); // 최댓값 갱신
        }

        return maxLIS;
    }
}
```

i와 j의 반복문을 보니 정렬 알고리즘인 것으로 보이는데

**DP(Dynamic Programming)**을 사용하여 해결할 수 있다고 한다.

- DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 **복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법**입니다. 문제 해결을 위해 알고리즘을 설계하는 방법이나 접근 방식을 나타냅니다. 설계 기법은 알고리즘을 개발하고 구현하는 데 사용되는 전략이나 원칙들을 포함합니다

#### **DP 배열 (`dp[i]`)**

- `dp[i]`: **`nums[i]`를 마지막 원소로 하는 증가 부분 수열의 최장 길이**
- 초기 상태: **모든 원소는 최소 1개의 수열을 가지므로 `dp[i] = 1` 로 설정**
- 갱신 방법: `nums[i] > nums[j] (j < i)`일 때, `dp[i]`를 `dp[j] + 1`로 갱신

### ** 동작 과정**

#### **🔹 Step 1: 초기 상태**

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
dp   = [ 1, 1, 1, 1, 1, 1, 1, 1 ]
```

모든 요소를 **1**로 초기화 (자기 자신만 있는 경우 길이는 1)

####  **Step 2: DP 테이블 갱신**

##### **i = 1 (nums[1] = 9)**

- `nums[1] < nums[0] (9 < 10)` → 패스

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

##### **i = 2 (nums[2] = 2)**

- `nums[2] < nums[0] (2 < 10)` → 패스
- `nums[2] < nums[1] (2 < 9)` → 패스

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

##### **i = 3 (nums[3] = 5)**

- `nums[3] > nums[2] (5 > 2)` → `dp[3] = max(1, dp[2] + 1) = 2`

```
dp = [1, 1, 1, 2, 1, 1, 1, 1]
```

##### **i = 4 (nums[4] = 3)**

- `nums[4] > nums[2] (3 > 2)` → `dp[4] = max(1, dp[2] + 1) = 2`

```
dp = [1, 1, 1, 2, 2, 1, 1, 1]
```

##### **i = 5 (nums[5] = 7)**

- `nums[5] > nums[2] (7 > 2)` → `dp[5] = max(1, dp[2] + 1) = 2`
- `nums[5] > nums[3] (7 > 5)` → `dp[5] = max(2, dp[3] + 1) = 3`
- `nums[5] > nums[4] (7 > 3)` → `dp[5] = max(3, dp[4] + 1) = 3`

```
dp = [1, 1, 1, 2, 2, 3, 1, 1]
```

##### **i = 6 (nums[6] = 101)**

- `nums[6] > nums[2] (101 > 2)` → `dp[6] = max(1, dp[2] + 1) = 2`
- `nums[6] > nums[3] (101 > 5)` → `dp[6] = max(2, dp[3] + 1) = 3`
- `nums[6] > nums[5] (101 > 7)` → `dp[6] = max(3, dp[5] + 1) = 4`

```
dp = [1, 1, 1, 2, 2, 3, 4, 1]
```

##### **i = 7 (nums[7] = 18)**

- `nums[7] > nums[2] (18 > 2)` → `dp[7] = max(1, dp[2] + 1) = 2`
- `nums[7] > nums[3] (18 > 5)` → `dp[7] = max(2, dp[3] + 1) = 3`
- `nums[7] > nums[5] (18 > 7)` → `dp[7] = max(3, dp[5] + 1) = 4`
- `nums[7] < nums[6] (18 < 101)` → 패스

```
dp = [1, 1, 1, 2, 2, 3, 4, 4]
```

### **최종 결과**

마지막으로, `dp` 배열에서 최댓값을 찾아 반환

```
max(dp) = 4
```
