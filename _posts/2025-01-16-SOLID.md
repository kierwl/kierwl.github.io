---
layout: single
comments: true
title: "유니티에서 설명하는 SOLID "
categories: TIL
tags: [C#,SOLID,Unity]
---

### 📆 오늘의 TIL (Today I Learned)

------

# SOLID 원칙



SOLID원칙은 객체지향을 공부하다 보면 접하게되는데

```
SRP(Single Responsibility Principle): 단일 책임 원칙
OCP(Open Closed Priciple): 개방 폐쇄 원칙
LSP(Listov Substitution Priciple): 리스코프 치환 원칙
ISP(Interface Segregation Principle): 인터페이스 분리 원칙
DIP(Dependency Inversion Principle): 의존 역전 원칙
```

의 앞글자를 따서 SOLID라 부른다.



## 1. SRP(Single Responsibility Principle): 단일 책임 원칙



SRP: 하나의 클래스는 하나의 채책임만을가지는 원칙이다.

개발을 하다보면 간혹 하나의 클래스에 여러가지 기능을 한번에 구현하게되는 경우가 종종 있는데 이는 단일책임원칙에 위반된다.



예로 플레이어를 기능을 구현하기 위해 클래스를 만든다고 생각해보자

플레이어는 사용자의 입력을 받아 움직여야 하고, 발자국이나, 소리나 음성이 나올 수 도 있을 것이다.

이런 기능들을 Player라는 클래스에 한번에 구현할 수도 있지만 이러면 단일 책임 원칙에 위반되기에 



원칙에 따라 코드를 작성하게 되면 오디오, 인풋, 움직임 등의 기능을 별도의 클래스로 나눠서 만들고 

이것들을 각각 별도의 컴포넌트로 구성하여 만들게 되는데 플레이어의 움직임만 구현하게 하고 싶을때 SRP를 지켰다면 Player movement스크립트 하나만 수정하면 되지만 SRP를 지키지 않을 경우 코드 전체를 수정해야하는 참사가 벌어 질 수 있다.

이렇게 작은 클래스로 쪼개서 만들게 되면 이점이 존재하는데 첫째로 가독성이 좋아지게 된다.

단일 기능 단위로 분리 했으니 코드의 길이가 짧고 명확해 진다.

두번째로 확장성이 좋아진다. 하나의 기능으로만 이루어 졌기에 이 클래스를 상속받아 확장하기 용이하다.

마지막으로 재사용성이 용이하다. 단일 기능으로 이루어 졌기 때문에 모듈식으로 재사용할 수 있다.



## 2.OCP(Open Closed Priciple): 개방 폐쇄 원칙

OCP 원칙은 클래스는 '확장에 열려있어야 하며, 수정에는 닫혀있어야 한다' 를 뜻한다.
기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법이다.

[ 확장에 열려있다 ] - 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음
[ 변경에 닫혀있다 ] - 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함. 

어렵게 생각할 필요없이, OCP 원칙은 추상화 사용을 통한 관계 구축을 권장을 의미하는 것이다.
즉, 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙



기존 코드에서는 도형별로 개별 함수가 존재하고 매개변수에서 도형을 각각 넣어 계산했다면 OCP에서는

공용으로 쓸수 있게 설계를 해야한다. shape라는 클래스를 만들고 넓이를 구하는 공용함수를 만든다.

이 클래스는 추상클래스로 설정한다.shape을 상속받아 도형의 클래스를 만들어주면 도형별로 넓이를 구하는 공식을 오버라이드한 함수안에 작성하는 것으로 도형이 추가되도 기존의 코드가 수정되지 않기에 OCP가 적용된 것을 알수있다.



## 3.리스코프 치환 원칙 - LSP (Liskov Substitution Principle)

LSP 원칙은 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙이다.
쉽게 말하면 LSP는 다형성 원리를 이용하기 위한 원칙 개념으로 보면 된다.
간단히 말하면 리스코프 치환 원칙이란, 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미하는 것이다.
따라서 기본적으로 LSP 원칙은 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야한다.왜냐하면 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문이다.

```
자바에선 대표적으로 Collection 인터페이스를 LSP의 예로 들수있다.
Collection 타입의 객체에서 자료형을 LinkedList에서 전혀 다른 자료형 HashSet으로 바꿔도 add() 메서드를 실행하는데 있어 원래 의도대로 작동되기 때문이다.
한마디로 다형성 이용을 위해 부모 타입으로 메서드를 실행해도 의도대로 실행되도록 구성을 해줘야 하는 원칙이라 이해하면 된다.
```





## 4.인터페이스 분리 원칙 - ISP (Interface Segregation Principle)

ISP 원칙은 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙이다.
SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조하는 것으로 보면 된다.
즉, SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계하는 원칙.
ISP 원칙은 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표이다.
다만 ISP 원칙의 주의해야 할점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말아야 한다. (인터페이스는 한번 구성하였으면 왜만해선 변하면 안되는 정책 개념)

## 5.의존 역전 원칙 - DIP (Dependency Inversion Principle

DIP 원칙은 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙 
쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 것
